#' @title Match cohort using mahalanobis distance
#'
#' @description This function builds couples of vaccinated - unvaccinated
#' individuals with similar characteristics. The function relies on  the
#' matching algorithm implemented in the package `{MatchIt}`.
#' By default the function uses `method = "nearest"`, `ratio = 1`,
#' `distance = "mahalanobis"` to match the data.
#' Exact and near characteristics are accepted for the matching criteria.
#' These are passed in the parameters `exact` and `nearest`, respectively.
#' The parameter `nearest` must be provided together with the calipers
#' following as a named vector.
#' (e.g. `nearest = c("characteristic1", "characteristic2"),
#' caliper = c(characteristic1 = n1, characteristic2 = n2)`,
#' where `n1` and `n2` are the calipers).
#' @inheritParams coh_effectiveness
#' @param exact name(s) of column(s) for `exact` matching.
#' Default to `NULL`.
#' @param nearest named vector with name(s) of column(s) for `nearest`
#' matching and caliper(s) for each variable.
#' e.g. `nearest = c("characteristic1" = n1, "characteristic2" = n2)`,
#' where `n1` and `n2` are the calipers. Default to `NULL`.
#' @return data frame with matched population. Two columns are added
#' to the structure provided in `data`:
#' `prop_score` (propensity score of the match),
#' `subclass` (id of matched couple)
#' @keywords internal
match_cohort_ <- function(data,
                          vacc_status_col,
                          exact = NULL,
                          nearest = NULL) {

  # input checking
  checkmate::assert_data_frame(
    data,
    min.rows = 1, min.cols = 1
  )
  checkmate::assert_character(vacc_status_col,
    any.missing = FALSE, min.len = 1
  )
  checkmate::assert_names(
    names(data),
    must.include = c(vacc_status_col)
  )

  # `exact` and `nearest` cannot be NULL. At least one must be provided
  stopifnot(
    "`exact` and `nearest` cannot be NULL. At least one must be provided" =
      (!missing(nearest) || !missing(exact))
  )

  # checks for `nearest`
  if (!is.null(nearest)) {
    checkmate::assert_numeric(
      nearest,
      any.missing = FALSE, min.len = 1, names = "named"
    )
    checkmate::assert_names(
      names(data),
      must.include = names(nearest)
    )
  }
  # checks for `exact`. Not else, both can be non-NULL
  if (!is.null(exact)) {
    checkmate::assert_character(exact,
      any.missing = FALSE, min.len = 1
    )
    checkmate::assert_names(
      names(data),
      must.include = exact
    )
  }

  #Formula
  variables <- c(exact, names(nearest))
  formula <- paste0(vacc_status_col, " ~ ")
  for (v in seq_along(variables)) {
    if (v == 1) {
      formula <- paste0(formula, variables[v])
    } else {
      formula <- paste0(formula, " + ", variables[v])
    }
  }
  formula_eval <- eval(parse(text = formula))
  data[[vacc_status_col]] <- as.factor(data[[vacc_status_col]])

  #Matching
  matchit <- MatchIt::matchit(
    formula_eval,
    data = data,
    method = "nearest",
    ratio = 1,
    exact = exact,
    nearest = names(nearest),
    caliper = nearest,
    distance = "mahalanobis"
  )
  match <- MatchIt::match.data(matchit)
  match <- match[, -which(names(match) == "weights")]
  return(match)
}

#' @title Match couple information
#'
#' @description This function matches numeric/date information of a
#' couple provided in the column `to_match`. This matching procedure is
#' required for sharing the censoring information and the exposure times
#' when adjusting and removing negative exposures generated by uncoherent
#' exposure dates.
#'
#' @inheritParams coh_effectiveness
#' @param column_to_match name of the column that contains the information
#' shared by the couples
#' @param criteria selection criteria when both individuals bring information.
#' This can be minimum (min) or maximum (max) value
#' @keywords internal
match_couple_info <- function(data,
                              column_to_match,
                              criteria = c("min", "max")) {
  matched_info <- unlist(
    tapply(data[[column_to_match]],
      data$subclass,
      function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          if (criteria == "min") {
            return(as.character(min(x, na.rm = TRUE)))
          } else if (criteria == "max") {
            return(as.character(max(x, na.rm = TRUE)))
          }
        }
      }
    )
  )
  # return data matched by subclass
  return(matched_info[data$subclass])
}


#' @title Match summary
#'
#' @description This function creates a summary after matching.
#' @inheritParams coh_effectiveness
#' @param all data frame with cohort
#' @param matched data frame with matched cohort
#' @param adjusted data frame with adjusted cohort to calculate removed
#' cases. Default Null returns 0.
#' @return summary data frame with counts by vaccine status for: all, matched,
#' unmatched and removed.
#' @keywords internal
match_summary <- function(all,
                          matched,
                          adjusted = NULL,
                          vacc_status_col) {
  summ_all <- as.data.frame(rbind(table(all[[vacc_status_col]])))
  summ_matched <- as.data.frame(rbind(table(matched[[vacc_status_col]])))
  summ_unmatched <- summ_all - summ_matched
  if (!is.null(adjusted)) {
    summ_removed <- summ_matched -
      as.data.frame(rbind(table(adjusted[[vacc_status_col]])))
  } else {
    summ_removed <- setNames(cbind.data.frame(0, 0), names(summ_all))
  }
  summ <- rbind(summ_all, summ_matched, summ_unmatched, summ_removed)
  row.names(summ) <- c("All", "Matched", "Unmatched", "Removed")

  return(summ)
}

#' @title Balance summary
#'
#' @description This function creates a summary after matching.
#' @inheritParams match_cohort
#' @param data data frame to asset matching balance
#' @return summary data frame with balance of each variable by vaccine status.
#' numeric variables are presented with mean and std and categorical/factor
#' are counted.
#' @keywords internal
balance_summary <- function(data,
                            nearest,
                            exact,
                            vacc_status_col) {
  columns <- c(names(nearest), exact)
  numeric <- columns[sapply(data[columns], is.numeric)]

  categorical <- columns[sapply(data[columns], is.character)]
  factor <- columns[sapply(data[columns], is.factor)]
  categorical <- c(categorical, factor)

  # balance for numeric variables
  balance_num <- data.frame()
  for (n in numeric) {
    temp <- as.data.frame(aggregate(
      data[n], list(data[[vacc_status_col]]),
      FUN = function(x) c(mean = mean(x), sd = sd(x))
    ))
    index <- temp[, 1]
    temp <- temp[, -1]
    rownames(temp) <- index
    colnames(temp) <- paste(n, colnames(temp), sep = "_")
    temp <- t(temp)
    balance_num <- rbind(balance_num, temp)
  }

  # balance for categorical/factor variables
  balance_cat <- data.frame()
  for (c in categorical) {
    temp <- as.data.frame(rbind(table(data[[c]], data[[vacc_status_col]])))
    rownames(temp) <- paste(c, row.names(temp), sep = "_")
    balance_cat <- rbind(balance_cat, temp)
  }
  balance <- rbind(balance_num, balance_cat)

  return(balance)
}
