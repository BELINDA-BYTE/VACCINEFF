#' @title Match Cohort Using Mahalanobis Distance
#'
#' @description This function constructs pairs of vaccinated and unvaccinated
#' individuals with similar characteristics. It relies on the matching
#' algorithm implemented in the package `{MatchIt}`.
#' By default, the function uses `method = "nearest"`, `ratio = 1`, and
#' `distance = "mahalanobis"` to perform the matching.
#' @inheritParams match_cohort
#' @return `data.frame` with the matched population.
#' @keywords internal
match_cohort_ <- function(data,
                          vacc_status_col,
                          exact = NULL,
                          nearest = NULL) {

  #Formula
  variables <- c(exact, names(nearest))
  formula <- paste0(vacc_status_col, " ~ ")
  for (v in seq_along(variables)) {
    if (v == 1) {
      formula <- paste0(formula, variables[v])
    } else {
      formula <- paste0(formula, " + ", variables[v])
    }
  }
  formula_eval <- eval(parse(text = formula))

  #Matching
  matchit <- MatchIt::matchit(
    formula_eval,
    data = data,
    method = "nearest",
    ratio = 1,
    exact = exact,
    nearest = names(nearest),
    caliper = nearest,
    distance = "mahalanobis"
  )
  match <- MatchIt::match.data(matchit)
  match <- match[, -which(names(match) == "weights")]
  return(match)
}

#' @title Match Information by Pairs
#'
#' @description This function matches numeric/date information of a
#' pair provided in the column `column_to_match`. This matching
#' procedure is required for sharing the censoring information and the
#' exposure times when adjusting and removing negative exposures
#' generated by incoherent exposure dates.
#'
#' @inheritParams match_cohort
#' @param column_to_match The name of the column that contains the information
#' shared by the pairs.
#' @param criteria Selection criteria when both individuals provide information.
#' This can be the minimum (min) or maximum (max) value.
#' @keywords internal
match_pair_info <- function(data,
                            column_to_match,
                            criteria = c("min", "max")) {
  matched_info <- unlist(
    tapply(data[[column_to_match]],
      data$subclass,
      function(x) {
        if (all(is.na(x))) {
          return(NA)
        } else {
          if (criteria == "min") {
            return(as.character(min(x, na.rm = TRUE)))
          } else if (criteria == "max") {
            return(as.character(max(x, na.rm = TRUE)))
          }
        }
      }
    )
  )
  # return data matched by subclass
  return(matched_info[data$subclass])
}

#' @title Constructs Summary with Results from Matching
#'
#' @description This function creates a summary for the results from
#' cohort matching. It provides counts grouped by vaccine status for
#' the entire population, the matched and unmatched populations,
#' and the records removed in case of adjusting the exposure time.
#'
#' @inheritParams match_cohort
#' @param all `data.frame` with the entire cohort.
#' @param matched `data.frame` with the matched cohort.
#' @param adjusted `data.frame` with the adjusted cohort to
#' calculate removed cases. Default is NULL, which returns 0.
#' @return Summary `data.frame` with counts by vaccine status for:
#' all, matched, unmatched, and removed.
#' @keywords internal
match_summary <- function(all,
                          matched,
                          adjusted = NULL,
                          vacc_status_col) {
  summ_all <- as.data.frame(rbind(table(all[[vacc_status_col]])))
  summ_matched <- as.data.frame(rbind(table(matched[[vacc_status_col]])))
  summ_unmatched <- summ_all - summ_matched
  if (!is.null(adjusted)) {
    summ_removed <- summ_matched -
      as.data.frame(rbind(table(adjusted[[vacc_status_col]])))
  } else {
    summ_removed <- stats::setNames(cbind.data.frame(0, 0), names(summ_all))
  }
  summ <- rbind(summ_all, summ_matched, summ_unmatched, summ_removed)
  row.names(summ) <- c("All", "Matched", "Unmatched", "Removed")

  return(summ)
}

#' @title Balance of Vaccinated/Unvaccinated Groups
#'
#' @description This function creates a summary after matching.
#' @inheritParams match_cohort
#' @param data `data.frame` to assess matching balance.
#' @return Summary `data.frame` with the balance of each variable by
#' vaccine status. Numeric variables are reported with means, and
#' categorical/factor variables are reported with proportions.
#' In both cases, the Standardized Mean Difference (SMD) is calculated.
#' @keywords internal
balance_summary <- function(data,
                            nearest,
                            exact,
                            vacc_status_col,
                            vaccinated_status,
                            unvaccinated_status) {
  columns <- c(names(nearest), exact)
  numeric <- columns[vapply(data[columns], is.numeric, logical(1))]

  categorical <- columns[vapply(data[columns], is.character, logical(1))]
  factor <- columns[vapply(data[columns], is.factor, logical(1))]
  categorical <- c(categorical, factor)

  # balance for numeric variables
  balance_num <- data.frame()
  for (n in numeric) {
    # mean and sd
    temp <- as.data.frame(stats::aggregate(
      data[n], list(data$vaccine_status),
      FUN = function(x) c(mean = mean(x), sd = stats::sd(x))
    ))
    temp <- do.call(data.frame, temp)
    # Std. Mean Diff.
    mean_v <- temp[2][temp$Group.1  == vaccinated_status, ]
    sd_v <- temp[3][temp$Group.1  == vaccinated_status, ]
    mean_u <- temp[2][temp$Group.1  == unvaccinated_status, ]
    sd_u <- temp[3][temp$Group.1  == unvaccinated_status, ]
    smd <- (mean_v - mean_u) / sqrt((sd_v^2 + sd_u^2) / 2)

    # Results
    summ_num <- data.frame(
      u = c(mean_u),
      v = c(mean_v),
      smd = c(smd)
    )
    colnames(summ_num) <- c(unvaccinated_status, vaccinated_status, "smd")
    rownames(summ_num) <- n

    balance_num <- rbind(balance_num, summ_num)
  }

  # balance for categorical/factor variables
  balance_cat <- data.frame()
  for (c in categorical) {
    # proportion by group
    temp <- as.data.frame(
      rbind(prop.table(table(data[[c]], data[[vacc_status_col]]), 2))
    )
    rownames(temp) <- paste(c, row.names(temp), sep = "_")

    # Std. Mean Diff.
    pooled <- sqrt(
      (temp[[vaccinated_status]] * (1 - temp[[vaccinated_status]]) +
         temp[[unvaccinated_status]] * (1 - temp[[unvaccinated_status]])) / 2
    )
    temp$smd <-
      (temp[[vaccinated_status]] - temp[[unvaccinated_status]]) / pooled
    # Results
    balance_cat <- rbind(balance_cat, temp)
  }

  balance <- rbind(balance_num, balance_cat)

  return(balance)
}
